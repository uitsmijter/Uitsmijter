# RFC 7517: JSON Web Key (JWK) Implementation Plan

## Implementation Status: ðŸ“‹ PLANNED

**RFC Reference**: https://www.rfc-editor.org/rfc/rfc7517
**Related RFCs**:
- RFC 7515 (JWS - JSON Web Signature)
- RFC 7516 (JWE - JSON Web Encryption)
- RFC 7518 (JWA - JSON Web Algorithms)

---

## Executive Summary

This document outlines the implementation plan for adding RFC 7517 (JSON Web Key) support to Uitsmijter. The JWK endpoint (`/.well-known/jwks.json`) allows clients to retrieve the public keys used to verify JWT signatures issued by the authorization server.

**Current State**: Uitsmijter advertises `jwks_uri` in OpenID Discovery but:
- âŒ No actual `/.well-known/jwks.json` endpoint exists
- âŒ Uses HS256 (symmetric) instead of RS256 (asymmetric) for JWT signing
- âŒ Cannot expose public keys (HS256 has no public key)
- âš ï¸ Advertises RS256 support but doesn't implement it

**This RFC Implementation Will**:
1. Migrate from HS256 to RS256 for JWT signing
2. Implement RSA key generation and storage
3. Create `/.well-known/jwks.json` endpoint exposing public keys
4. Support key rotation with `kid` (Key ID)
5. Maintain backward compatibility during migration

## Why RFC 7517 / JWKS?

### Security Benefits
- **Public Key Cryptography**: RS256 allows clients to verify JWTs without sharing secrets
- **Key Distribution**: JWKS provides a standard mechanism for distributing public keys
- **No Shared Secrets**: Eliminates the risk of secret key compromise across many clients
- **Standard Compliance**: Required for proper OIDC/OAuth 2.0 implementation

### Interoperability
- **OAuth 2.0 Best Practice**: Industry standard for authorization servers
- **Client Libraries**: All major OAuth/OIDC libraries expect RS256 + JWKS
- **Federation**: Enables federated identity across different domains
- **Third-Party Integration**: External services can verify tokens without backend calls

### Current Problems with HS256
- **Security Risk**: Symmetric key must be shared with all clients for verification
- **No Key Distribution**: No standard way to distribute the shared secret
- **Not OIDC Compliant**: OIDC requires RS256 support
- **Scalability Issues**: Every client needs the secret, increasing attack surface

## RFC 7517 Key Requirements

### 1. JWK Data Structure

**Required Parameters**:
- `kty`: Key type (e.g., "RSA", "EC")

**Common Optional Parameters**:
- `use`: Public key usage ("sig" for signatures, "enc" for encryption)
- `kid`: Key ID for matching during key rollover
- `alg`: Intended algorithm (e.g., "RS256")
- `n`: RSA modulus (Base64urlUInt-encoded)
- `e`: RSA exponent (Base64urlUInt-encoded)

**Example RSA Public Key**:
```json
{
  "kty": "RSA",
  "use": "sig",
  "kid": "2024-11-08",
  "alg": "RS256",
  "n": "0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78...",
  "e": "AQAB"
}
```

### 2. JWK Set Structure

**Required**:
- `keys`: Array of JWK objects

**Example JWK Set**:
```json
{
  "keys": [
    {
      "kty": "RSA",
      "use": "sig",
      "kid": "2024-11-08",
      "alg": "RS256",
      "n": "0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78...",
      "e": "AQAB"
    }
  ]
}
```

### 3. Security Requirements

**Private Key Protection**:
- Private keys MUST never be exposed via JWKS endpoint
- Encrypt private keys at rest using JWE (JSON Web Encryption)
- Store private keys securely (file system with restricted permissions or HSM)

**Key Rotation**:
- Support multiple keys simultaneously during rotation
- Use `kid` to identify which key signed which token
- Maintain old keys temporarily for token verification during transition

**Certificate Handling** (Optional):
- Support X.509 certificate chains via `x5c` parameter
- Validate certificate chains when using `x5u` (URI to certificates)

## Current Uitsmijter Architecture Analysis

### Existing Infrastructure

#### 1. JWT Signing (Currently HS256)
**Location**: `Sources/Uitsmijter-AuthServer/JWT/Signer.swift`

**Current Implementation**:
```swift
fileprivate let jwtSecret = ProcessInfo.processInfo.environment["JWT_SECRET"] ?? String.random(length: 64)
nonisolated(unsafe) let jwt_signer = JWTSigner.hs256(key: jwtSecret)
```

**Assessment**: âŒ Uses symmetric HS256, needs to be replaced with RS256

#### 2. OpenID Discovery Configuration
**Location**: `Sources/Uitsmijter-AuthServer/WellKnown/OpenidConfigurationBuilder.swift:171`

**Current Implementation**:
```swift
let jwksUri = "\(issuer)/.well-known/jwks.json"
```

**Assessment**: âœ… Already advertises JWKS URI, but endpoint doesn't exist

#### 3. Advertised Signing Algorithms
**Location**: `Sources/Uitsmijter-AuthServer/WellKnown/OpenidConfigurationBuilder.swift:55`

**Current Implementation**:
```swift
private static let defaultIdTokenSigningAlgorithms = ["RS256"]
```

**Assessment**: âš ï¸ Advertises RS256 but actually uses HS256 (false advertising!)

#### 4. JWT Payload Structure
**Location**: `Sources/Uitsmijter-AuthServer/JWT/Payload.swift`

**Current Fields**:
- `iss` (issuer)
- `sub` (subject)
- `aud` (audience)
- `exp` (expiration)
- `iat` (issued at)
- `auth_time`
- `tenant`
- Custom profile data

**Assessment**: âœ… Standard OIDC payload structure, compatible with RS256

### Missing Components

1. **RSA Key Pair Generation**: No code for generating RSA keys
2. **Key Storage**: No mechanism for storing private/public key pairs
3. **JWKS Endpoint Controller**: No `/.well-known/jwks.json` route
4. **JWK Serialization**: No code to convert RSA keys to JWK format
5. **Key Rotation Logic**: No support for `kid` or multiple active keys
6. **Migration Path**: No strategy for transitioning from HS256 to RS256

## Implementation Plan

### Phase 1: RSA Key Management (Estimated: 6-8 hours)

#### Task 1.1: Create RSA Key Pair Generator
**File**: `Sources/Uitsmijter-AuthServer/JWT/KeyGenerator.swift` (new)

**Implementation**:
```swift
import Foundation
import JWTKit

/// Actor responsible for generating and managing RSA key pairs for JWT signing.
///
/// This actor provides thread-safe key generation and management according to
/// RFC 7517 (JSON Web Key) requirements. Keys are generated using RSA-2048 or
/// RSA-4096 depending on security requirements.
///
/// ## Key Generation
///
/// Keys are generated with:
/// - 2048-bit or 4096-bit modulus
/// - Public exponent of 65537 (0x010001)
/// - Unique Key ID (kid) based on generation timestamp
///
/// ## Security
///
/// - Private keys are never exposed outside this actor
/// - Keys can be encrypted at rest using JWE
/// - Supports secure key rotation
///
actor KeyGenerator {

    /// Generate a new RSA key pair for JWT signing
    ///
    /// - Parameters:
    ///   - keySize: RSA key size in bits (2048 or 4096)
    ///   - kid: Optional key identifier. If nil, generates timestamp-based ID
    /// - Returns: Tuple containing the JWTKit signer and JWK representation
    /// - Throws: KeyGenerationError if key creation fails
    func generateRSAKeyPair(
        keySize: Int = 2048,
        kid: String? = nil
    ) throws -> (signer: JWTSigner, jwk: RSAPublicJWK) {
        // Generate RSA key pair using JWTKit
        let keyID = kid ?? generateKeyID()
        let key = try RSAKey.generate(bits: keySize)

        // Create signer
        let signer = JWTSigner.rs256(key: key)

        // Extract public key components for JWK
        let publicJWK = RSAPublicJWK(
            kty: "RSA",
            use: "sig",
            kid: keyID,
            alg: "RS256",
            n: key.modulus.base64URLEncodedString(),
            e: key.exponent.base64URLEncodedString()
        )

        return (signer, publicJWK)
    }

    /// Generate a unique key identifier based on current timestamp
    ///
    /// Format: "YYYY-MM-DD-HHmmss" (e.g., "2024-11-08-143022")
    ///
    /// - Returns: Unique key identifier string
    private func generateKeyID() -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd-HHmmss"
        return formatter.string(from: Date())
    }

    /// Encrypt a private key for secure storage
    ///
    /// Uses JWE (JSON Web Encryption) to encrypt the private key material.
    ///
    /// - Parameters:
    ///   - key: The RSA private key to encrypt
    ///   - password: Password for encryption
    /// - Returns: Encrypted JWE string
    /// - Throws: EncryptionError if encryption fails
    func encryptPrivateKey(
        _ key: RSAKey,
        password: String
    ) throws -> String {
        // TODO: Implement JWE encryption
        // For now, this is a placeholder
        fatalError("Not implemented - use secure storage")
    }
}
```

**Acceptance Criteria**:
- [ ] Can generate 2048-bit RSA key pairs
- [ ] Can generate 4096-bit RSA key pairs
- [ ] Generates unique `kid` based on timestamp
- [ ] Extracts public key components (n, e) correctly
- [ ] Returns both signer and JWK representation
- [ ] Thread-safe (actor isolation)
- [ ] Unit tests cover all key sizes
- [ ] Performance: Key generation < 500ms

#### Task 1.2: Create JWK Data Models
**File**: `Sources/Uitsmijter-AuthServer/JWT/JWK.swift` (new)

**Implementation**:
```swift
import Foundation

/// RSA Public Key in JSON Web Key (JWK) format
///
/// Represents a public RSA key according to RFC 7517 Section 6.3.1.
/// Contains the public key components (modulus and exponent) that can be
/// distributed to clients for JWT signature verification.
///
/// ## Example
///
/// ```json
/// {
///   "kty": "RSA",
///   "use": "sig",
///   "kid": "2024-11-08",
///   "alg": "RS256",
///   "n": "0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78...",
///   "e": "AQAB"
/// }
/// ```
///
/// - SeeAlso: [RFC 7517 Section 6.3.1](https://www.rfc-editor.org/rfc/rfc7517#section-6.3.1)
struct RSAPublicJWK: Codable, Sendable {

    /// Key Type (REQUIRED)
    ///
    /// The "kty" (key type) parameter identifies the cryptographic algorithm
    /// family used with the key. For RSA keys, this MUST be "RSA".
    let kty: String

    /// Public Key Use (OPTIONAL)
    ///
    /// The "use" (public key use) parameter identifies the intended use of
    /// the public key:
    /// - "sig": signature verification
    /// - "enc": encryption
    let use: String?

    /// Key ID (OPTIONAL but RECOMMENDED)
    ///
    /// The "kid" (key ID) parameter is used to match a specific key during
    /// key rollover. This parameter is matched to the "kid" parameter in
    /// the JWT header.
    let kid: String?

    /// Algorithm (OPTIONAL)
    ///
    /// The "alg" (algorithm) parameter identifies the algorithm intended for
    /// use with the key. For RSA signature keys, this is typically "RS256".
    let alg: String?

    /// Modulus (REQUIRED for RSA)
    ///
    /// The "n" (modulus) parameter contains the modulus value for the RSA
    /// public key. It is represented as a Base64urlUInt-encoded value.
    let n: String

    /// Exponent (REQUIRED for RSA)
    ///
    /// The "e" (exponent) parameter contains the exponent value for the RSA
    /// public key. It is represented as a Base64urlUInt-encoded value.
    /// Commonly "AQAB" which represents 65537.
    let e: String
}

/// JWK Set - Collection of JSON Web Keys
///
/// A JWK Set is a JSON object that represents a set of JWKs. The value of
/// the "keys" parameter is an array of JWK values.
///
/// ## Example
///
/// ```json
/// {
///   "keys": [
///     {
///       "kty": "RSA",
///       "kid": "2024-11-08",
///       "use": "sig",
///       "alg": "RS256",
///       "n": "...",
///       "e": "AQAB"
///     },
///     {
///       "kty": "RSA",
///       "kid": "2024-11-01",
///       "use": "sig",
///       "alg": "RS256",
///       "n": "...",
///       "e": "AQAB"
///     }
///   ]
/// }
/// ```
///
/// - SeeAlso: [RFC 7517 Section 5](https://www.rfc-editor.org/rfc/rfc7517#section-5)
struct JWKSet: Codable, Sendable {

    /// Array of JWK values (REQUIRED)
    ///
    /// The "keys" parameter contains an array of JSON Web Key values.
    /// The array MAY contain multiple keys with different "kid" values
    /// to support key rotation.
    let keys: [RSAPublicJWK]

    /// Create a JWK Set with a single key
    ///
    /// - Parameter key: The JWK to include in the set
    /// - Returns: A new JWK Set containing the single key
    init(key: RSAPublicJWK) {
        self.keys = [key]
    }

    /// Create a JWK Set with multiple keys
    ///
    /// - Parameter keys: Array of JWKs to include in the set
    /// - Returns: A new JWK Set containing all keys
    init(keys: [RSAPublicJWK]) {
        self.keys = keys
    }
}
```

**Acceptance Criteria**:
- [ ] RSAPublicJWK conforms to Codable
- [ ] All required JWK parameters included (kty, n, e)
- [ ] Optional parameters supported (kid, use, alg)
- [ ] JWKSet structure with keys array
- [ ] JSON encoding produces RFC 7517 compliant output
- [ ] Documentation includes RFC references
- [ ] Unit tests verify JSON structure
- [ ] Sendable conformance for concurrency

#### Task 1.3: Implement Key Storage
**File**: `Sources/Uitsmijter-AuthServer/JWT/KeyStorage.swift` (new)

**Requirements**:
- Store private keys securely (file system or environment variable)
- Load keys on startup
- Support key rotation (maintain multiple active keys)
- Thread-safe access (use actor)
- Configuration via environment variables:
  - `JWT_PRIVATE_KEY_PATH`: Path to private key file(s)
  - `JWT_KEY_ID`: Current active key ID
  - Migration: Fall back to HS256 if no RSA key configured

**Acceptance Criteria**:
- [ ] Can load RSA private keys from files
- [ ] Can generate new keys if none exist
- [ ] Supports multiple active keys (key rotation)
- [ ] Thread-safe key access
- [ ] Graceful degradation to HS256 during migration
- [ ] Keys persist across restarts
- [ ] File permissions validated (0600 for private keys)
- [ ] Environment variable configuration
- [ ] Unit tests with temporary key files

#### Task 1.4: Update Signer to Support RS256
**File**: `Sources/Uitsmijter-AuthServer/JWT/Signer.swift` (modify)

**Changes**:
```swift
import Foundation
import JWTKit

/// JWT Signing configuration and signers
///
/// Provides both HS256 (symmetric) and RS256 (asymmetric) signing capabilities.
/// The active signer is determined by environment configuration.
///
/// ## Migration Path
///
/// 1. HS256 Only (current): Uses JWT_SECRET
/// 2. Dual Mode (migration): Supports both HS256 and RS256
/// 3. RS256 Only (future): Only RSA signatures
///
actor SignerManager {

    /// Current active signer (RS256 preferred, falls back to HS256)
    private var activeSigner: JWTSigner

    /// Current key ID for the active signer
    private var activeKeyID: String

    /// All available signers (for key rotation)
    private var availableSigners: [String: JWTSigner] = [:]

    /// Initialize with key storage
    ///
    /// - Parameter keyStorage: Key storage containing RSA keys
    init(keyStorage: KeyStorage) async {
        // Try to load RSA key first
        if let (signer, kid) = await keyStorage.loadActiveRSAKey() {
            self.activeSigner = signer
            self.activeKeyID = kid
            self.availableSigners[kid] = signer
        } else {
            // Fall back to HS256
            let secret = ProcessInfo.processInfo.environment["JWT_SECRET"] ?? String.random(length: 64)
            self.activeSigner = JWTSigner.hs256(key: secret)
            self.activeKeyID = "hs256-fallback"
            self.availableSigners["hs256-fallback"] = activeSigner
        }
    }

    /// Sign a payload with the active signer
    ///
    /// - Parameter payload: The JWT payload to sign
    /// - Returns: Signed JWT string
    /// - Throws: JWTError if signing fails
    func sign<Payload: JWTPayload>(_ payload: Payload) async throws -> String {
        try activeSigner.sign(payload, kid: activeKeyID)
    }

    /// Verify a JWT using any available signer
    ///
    /// Automatically selects the correct signer based on the "kid" header.
    ///
    /// - Parameters:
    ///   - token: JWT string to verify
    ///   - type: Expected payload type
    /// - Returns: Verified payload
    /// - Throws: JWTError if verification fails
    func verify<Payload: JWTPayload>(_ token: String, as type: Payload.Type) async throws -> Payload {
        // Extract kid from header
        let parts = token.split(separator: ".")
        guard parts.count == 3,
              let headerData = Data(base64URLEncoded: String(parts[0])),
              let header = try? JSONDecoder().decode(JWTHeader.self, from: headerData),
              let kid = header.kid,
              let signer = availableSigners[kid] else {
            // Try all signers if kid not found
            for signer in availableSigners.values {
                if let payload = try? signer.verify(token, as: type) {
                    return payload
                }
            }
            throw JWTError.verificationFailed
        }

        return try signer.verify(token, as: type)
    }
}

// Global signer manager (initialized in configure.swift)
nonisolated(unsafe) var jwt_signer_manager: SignerManager?
```

**Acceptance Criteria**:
- [ ] Supports both HS256 and RS256 signing
- [ ] Prefers RS256 when available
- [ ] Falls back to HS256 if no RSA key
- [ ] Includes "kid" in JWT header
- [ ] Can verify tokens with different kids
- [ ] Thread-safe (actor isolation)
- [ ] Backward compatible with existing HS256 tokens
- [ ] Unit tests for both algorithms
- [ ] Integration tests with real keys

### Phase 2: JWKS Endpoint Implementation (Estimated: 3-4 hours)

#### Task 2.1: Create JWKS Controller
**File**: `Sources/Uitsmijter-AuthServer/Controllers/JWKSController.swift` (new)

**Implementation**:
```swift
import Foundation
import Vapor
import Logger

/// Controller for JSON Web Key Set (JWKS) endpoint.
///
/// The `JWKSController` provides the `/.well-known/jwks.json` endpoint for
/// distributing public keys used to verify JWT signatures. This implements
/// RFC 7517 (JSON Web Key) requirements.
///
/// ## Purpose
///
/// Clients use this endpoint to retrieve the authorization server's public keys
/// for verifying JWT signatures. This enables:
/// - Token verification without shared secrets
/// - Key rotation support
/// - Standard OIDC/OAuth 2.0 compliance
///
/// ## Routes
///
/// - `GET /.well-known/jwks.json` - Returns JWK Set with public keys
///
/// ## Response Format
///
/// ```json
/// {
///   "keys": [
///     {
///       "kty": "RSA",
///       "use": "sig",
///       "kid": "2024-11-08",
///       "alg": "RS256",
///       "n": "0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78...",
///       "e": "AQAB"
///     }
///   ]
/// }
/// ```
///
/// ## Security
///
/// - Only public keys are exposed (never private keys)
/// - Endpoint is publicly accessible (no authentication required)
/// - Cached responses (1 hour) for performance
/// - No sensitive information disclosed
///
/// ## Multi-Tenant Support
///
/// Each tenant can have different signing keys. The endpoint returns keys
/// specific to the tenant making the request (resolved from Host header).
///
/// - SeeAlso: [RFC 7517](https://www.rfc-editor.org/rfc/rfc7517)
/// - SeeAlso: ``JWKSet``
/// - SeeAlso: ``RSAPublicJWK``
struct JWKSController: RouteCollection {

    /// Registers JWKS routes with the application.
    ///
    /// - Parameter routes: The routes builder to register endpoints with
    /// - Throws: Routing configuration errors
    func boot(routes: RoutesBuilder) throws {
        let wellKnown = routes.grouped(".well-known")
        wellKnown.get("jwks.json", use: getJWKS)
    }

    /// GET /.well-known/jwks.json - Returns public key set
    ///
    /// This endpoint returns the JSON Web Key Set containing all public keys
    /// used for JWT signature verification. Clients should cache this response
    /// and refresh when token verification fails.
    ///
    /// ## Response Headers
    ///
    /// - Content-Type: application/json
    /// - Cache-Control: public, max-age=3600 (1 hour)
    /// - Access-Control-Allow-Origin: * (CORS enabled)
    ///
    /// ## Error Handling
    ///
    /// - Returns empty key set if no RSA keys configured (during migration)
    /// - Returns 500 if key loading fails unexpectedly
    ///
    /// - Parameter req: The incoming HTTP request
    /// - Returns: JWK Set as JSON
    /// - Throws: Abort on unexpected errors
    @Sendable
    func getJWKS(req: Request) async throws -> Response {
        Log.info("JWKS requested", requestId: req.id)

        // Get key storage
        guard let keyStorage = req.application.keyStorage else {
            Log.warning("Key storage not initialized, returning empty JWKS", requestId: req.id)
            // Return empty key set during migration period
            let emptySet = JWKSet(keys: [])
            return try await encodeJWKS(emptySet, req: req)
        }

        // Get all public keys
        let publicKeys = await keyStorage.getPublicKeys()

        if publicKeys.isEmpty {
            Log.warning("No RSA keys available, returning empty JWKS", requestId: req.id)
        } else {
            Log.info("Returning \(publicKeys.count) public key(s)", requestId: req.id)
        }

        // Build JWK Set
        let jwkSet = JWKSet(keys: publicKeys)

        return try await encodeJWKS(jwkSet, req: req)
    }

    /// Encode JWK Set to JSON response with appropriate headers
    ///
    /// - Parameters:
    ///   - jwkSet: The JWK Set to encode
    ///   - req: The incoming request
    /// - Returns: JSON response with proper headers
    /// - Throws: Abort if encoding fails
    private func encodeJWKS(_ jwkSet: JWKSet, req: Request) async throws -> Response {
        let encoder = JSONEncoder()
        encoder.outputFormatting = [.prettyPrinted, .sortedKeys, .withoutEscapingSlashes]

        guard let jsonData = try? encoder.encode(jwkSet),
              let jsonString = String(data: jsonData, encoding: .utf8) else {
            Log.error("Failed to encode JWKS to JSON", requestId: req.id)
            throw Abort(.internalServerError, reason: "Failed to generate JWKS")
        }

        // Create response with appropriate headers
        var headers = HTTPHeaders()
        headers.add(name: .contentType, value: "application/json; charset=utf-8")
        headers.add(name: .cacheControl, value: "public, max-age=3600")
        headers.add(name: "Access-Control-Allow-Origin", value: "*")
        headers.add(name: "X-Content-Type-Options", value: "nosniff")

        return Response(
            status: .ok,
            headers: headers,
            body: .init(string: jsonString)
        )
    }
}
```

**Acceptance Criteria**:
- [ ] Endpoint registered at `GET /.well-known/jwks.json`
- [ ] Returns JWK Set with all public keys
- [ ] Only exposes public keys (never private)
- [ ] Returns empty key set if no RSA keys (migration)
- [ ] Proper HTTP headers (Content-Type, Cache-Control, CORS)
- [ ] JSON formatted with pretty-print and sorted keys
- [ ] Comprehensive logging
- [ ] DocC documentation
- [ ] Unit tests with mock key storage
- [ ] Integration tests with real keys

#### Task 2.2: Register JWKS Route
**File**: `Sources/Uitsmijter-AuthServer/routes.swift` (modify)

**Changes**:
```swift
// OAuth Flow
try app.register(collection: WellKnownController())
try app.register(collection: JWKSController())  // ADD THIS LINE
try app.register(collection: AuthorizeController())
try app.register(collection: TokenController())
try app.register(collection: RevokeController())
```

**Acceptance Criteria**:
- [ ] Route registered in correct position (after WellKnownController)
- [ ] Uses same middleware as other endpoints
- [ ] No breaking changes to existing routes

#### Task 2.3: Update JWT Payload to Include "kid"
**File**: `Sources/Uitsmijter-AuthServer/JWT/Token.swift` (modify)

**Changes**:
- Add "kid" to JWT header during signing
- Ensure "kid" matches the key used for signing
- Update Token initialization to accept kid parameter

**Acceptance Criteria**:
- [ ] JWT header includes "kid" parameter
- [ ] "kid" matches active signing key
- [ ] Backward compatible with tokens without "kid"
- [ ] Unit tests verify "kid" in header
- [ ] Integration tests with verification

### Phase 3: Migration Strategy (Estimated: 4-5 hours)

#### Task 3.1: Implement Dual-Mode Support

**Strategy**:
1. **Week 1**: Deploy with RSA key generation + dual signature support
   - Generate RSA keys on first startup
   - Sign new tokens with RS256 + kid
   - Verify tokens with both HS256 and RS256

2. **Week 2-4**: Monitor and validate
   - All new tokens use RS256
   - Old HS256 tokens still valid (until expiration)
   - Monitor token verification metrics

3. **Week 5+**: Deprecate HS256
   - Stop accepting HS256 tokens
   - Remove HS256 fallback code
   - RS256 only mode

**Configuration**:
- `JWT_MIGRATION_MODE`: `dual` (default), `rs256-only`, `hs256-only`
- `JWT_HS256_EXPIRY_DATE`: Date after which HS256 tokens rejected
- `JWT_PRIVATE_KEY_PATH`: Path to RSA private key

**Acceptance Criteria**:
- [ ] Can sign with RS256 while verifying both
- [ ] Graceful degradation if RSA key missing
- [ ] Configuration via environment variables
- [ ] Clear logging of migration state
- [ ] Metrics for algorithm usage
- [ ] Documentation for operators

#### Task 3.2: Add Metrics for Key Usage

**File**: `Sources/Uitsmijter-AuthServer/Monitoring/Prometheus.swift` (modify)

**New Metrics**:
```swift
var metricsJWTSigned: PromCounter<Int>?  // Track tokens signed by algorithm
var metricsJWTVerified: PromCounter<Int>?  // Track tokens verified by algorithm
var metricsJWKSRequests: PromCounter<Int>?  // Track JWKS endpoint requests
```

**Labels**:
- `algorithm`: "RS256" or "HS256"
- `kid`: Key identifier
- `result`: "success" or "failure"

**Acceptance Criteria**:
- [ ] Metrics track signing algorithm usage
- [ ] Metrics track verification algorithm usage
- [ ] JWKS endpoint requests counted
- [ ] Labels capture relevant dimensions
- [ ] Documented in metrics table

### Phase 4: Testing (Estimated: 5-6 hours)

#### Task 4.1: Unit Tests

**File**: `Tests/Uitsmijter-AuthServerTests/JWT/KeyGeneratorTest.swift` (new)

**Test Cases**:
1. Generate 2048-bit RSA key pair
2. Generate 4096-bit RSA key pair
3. Validate unique kid generation
4. Validate JWK structure (kty, n, e, kid, alg, use)
5. Validate public key extraction
6. Performance: Key generation time

**File**: `Tests/Uitsmijter-AuthServerTests/JWT/JWKTest.swift` (new)

**Test Cases**:
1. RSAPublicJWK JSON encoding
2. RSAPublicJWK JSON decoding
3. JWKSet with single key
4. JWKSet with multiple keys
5. JWKSet JSON structure compliance

**File**: `Tests/Uitsmijter-AuthServerTests/JWT/SignerManagerTest.swift` (new)

**Test Cases**:
1. Sign with RS256
2. Verify RS256 signature
3. Sign with HS256 (fallback)
4. Verify HS256 signature
5. Cross-verification (RS256 vs HS256)
6. kid matching during verification
7. Multiple key support

**File**: `Tests/Uitsmijter-AuthServerTests/Controllers/JWKSControllerTest.swift` (new)

**Test Cases**:
1. GET /.well-known/jwks.json returns valid JWK Set
2. Response has correct Content-Type
3. Response has Cache-Control header
4. Empty key set during migration
5. Multiple keys in response
6. CORS headers present

**Acceptance Criteria**:
- [ ] All test cases pass
- [ ] Code coverage > 90%
- [ ] Tests use VaporTesting framework
- [ ] Tests verify RFC 7517 compliance
- [ ] Performance tests for key generation

#### Task 4.2: Integration Tests

**File**: `Tests/Uitsmijter-AuthServerTests/Integration/JWKSFlowTest.swift` (new)

**Test Scenarios**:
1. Generate RSA key â†’ Sign JWT â†’ Verify with JWKS public key
2. Key rotation: Multiple keys â†’ Verify old and new tokens
3. Migration: Sign with RS256 â†’ Verify old HS256 tokens
4. External verification: Export JWKS â†’ Verify with external library

**Acceptance Criteria**:
- [ ] End-to-end RSA signing and verification works
- [ ] Key rotation doesn't break existing tokens
- [ ] Migration path validated
- [ ] External libraries can verify tokens using JWKS

#### Task 4.3: E2E Tests

**Directory**: `Tests/e2e/playwright/tests/OAuth/`

**New Test File**: `JWKSDiscovery.spec.ts`

**Test Scenarios**:
1. Fetch /.well-known/openid-configuration â†’ Extract jwks_uri â†’ Fetch JWKS
2. Obtain OAuth token â†’ Extract kid from header â†’ Match kid in JWKS
3. Verify token signature using public key from JWKS (with external library)

**Acceptance Criteria**:
- [ ] E2E tests pass in all browsers
- [ ] JWKS discovery works end-to-end
- [ ] Token verification with JWKS succeeds
- [ ] Tests run in CI/CD pipeline

### Phase 5: Documentation (Estimated: 3-4 hours)

#### Task 5.1: Update API Documentation

**File**: `Documentation/content/oauth/endpoints.md`

**New Section** (insert after `/token/info` section):

````markdown
### /.well-known/jwks.json

The `/.well-known/jwks.json` endpoint provides the JSON Web Key Set (JWKS) containing the public keys used to verify JWT signatures. This endpoint implements [RFC 7517: JSON Web Key](https://www.rfc-editor.org/rfc/rfc7517).

**Why use JWKS?**

- **Token Verification**: Clients can verify JWT signatures without contacting the authorization server
- **No Shared Secrets**: Public key cryptography eliminates the need for shared secrets
- **Key Rotation**: Supports multiple keys for seamless key rotation
- **Standard Compliance**: Required for proper OIDC/OAuth 2.0 implementation

**Request**:

```shell
curl --request GET \
  --url https://id.example.com/.well-known/jwks.json \
  --header 'Accept: application/json'
```

**Response**:

```json
{
  "keys": [
    {
      "kty": "RSA",
      "use": "sig",
      "kid": "2024-11-08",
      "alg": "RS256",
      "n": "0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78LUVyP3BD3Y...",
      "e": "AQAB"
    }
  ]
}
```

**Parameter description**:

| Parameter | Description                                                                                   |
|-----------|-----------------------------------------------------------------------------------------------|
| kty       | Key type. Always "RSA" for RSA keys.                                                          |
| use       | Public key use. "sig" for signature verification.                                             |
| kid       | Key ID. Used to match the "kid" parameter in the JWT header during key rotation.             |
| alg       | Algorithm intended for use with the key. "RS256" for RSA with SHA-256.                       |
| n         | RSA modulus. Base64url-encoded public key component.                                          |
| e         | RSA exponent. Base64url-encoded public key component. Typically "AQAB" (65537).              |

**Key Rotation**:

During key rotation, the JWKS endpoint may return multiple keys with different `kid` values. Clients should:
1. Cache the JWKS response
2. Match the `kid` from the JWT header to the corresponding key in the JWKS
3. Refresh the JWKS cache if token verification fails
4. Implement appropriate caching (recommended: 1 hour based on Cache-Control header)

**Example: Verifying a JWT with JWKS (JavaScript)**:

```javascript
import { createRemoteJWKSet, jwtVerify } from 'jose';

// Create JWKS client (automatically fetches and caches public keys)
const JWKS = createRemoteJWKSet(new URL('https://id.example.com/.well-known/jwks.json'));

// Verify JWT
try {
  const { payload } = await jwtVerify(token, JWKS, {
    issuer: 'https://id.example.com',
    audience: 'your-client-id'
  });
  console.log('Token is valid:', payload);
} catch (error) {
  console.error('Token verification failed:', error);
}
```

**Caching**:

The JWKS endpoint returns a `Cache-Control: public, max-age=3600` header. Clients should:
- Cache the JWKS response for 1 hour
- Refresh the cache when token verification fails
- Implement automatic retry with fresh JWKS on verification failure

**Security Considerations**:

- Only public keys are exposed (private keys are never transmitted)
- Always use HTTPS to fetch JWKS
- Validate the issuer and audience claims in addition to signature verification
- Implement proper JWKS caching to avoid excessive requests

> **Note**: The JWKS endpoint is publicly accessible and does not require authentication.
````

**Acceptance Criteria**:
- [ ] Documentation is clear and comprehensive
- [ ] Includes practical examples (curl and JavaScript)
- [ ] References RFC 7517
- [ ] Explains key rotation
- [ ] Covers security considerations
- [ ] Shows integration with popular libraries

#### Task 5.2: Update Discovery Documentation

**File**: `Documentation/content/oauth/endpoints.md`

**Update**: Add JWKS description to the discovery endpoint example

```json
{
  "issuer": "https://id.example.com",
  "authorization_endpoint": "https://id.example.com/authorize",
  "token_endpoint": "https://id.example.com/token",
  "jwks_uri": "https://id.example.com/.well-known/jwks.json",  // HIGHLIGHT THIS
  "userinfo_endpoint": "https://id.example.com/userinfo",
  ...
}
```

Add explanation:
- `jwks_uri`: REQUIRED. URL of the JSON Web Key Set containing the server's public keys

**Acceptance Criteria**:
- [ ] Discovery example highlights jwks_uri
- [ ] Linked to JWKS endpoint documentation

#### Task 5.3: Create Migration Guide

**File**: `Documentation/content/oauth/jwt-migration.md` (new)

**Content**:
- Overview of HS256 â†’ RS256 migration
- Why the migration is necessary
- Step-by-step migration instructions
- Configuration options
- Rollback procedures
- Troubleshooting common issues
- Timeline and milestones

**Acceptance Criteria**:
- [ ] Complete migration guide
- [ ] Clear instructions for operators
- [ ] Configuration examples
- [ ] Troubleshooting section

#### Task 5.4: Update Metrics Documentation

**File**: `Documentation/content/oauth/endpoints.md` (modify /metrics section)

**Add new metrics**:

```markdown
| `uitsmijter_jwt_signed`    | Counter of JWTs signed by algorithm (RS256, HS256) and result.              |
| `uitsmijter_jwt_verified`  | Counter of JWTs verified by algorithm (RS256, HS256) and result.            |
| `uitsmijter_jwks_requests` | Counter of JWKS endpoint requests.                                          |
```

**Acceptance Criteria**:
- [ ] Metrics documented with descriptions
- [ ] Table formatting consistent
- [ ] Algorithm labels explained

### Phase 6: CHANGELOG and Release (Estimated: 1 hour)

#### Task 6.1: Update CHANGELOG

**File**: `CHANGELOG.md`

**Add to 0.10.0 section** (in Features):
```markdown
- Feature: **RFC 7517 JSON Web Key (JWK)** endpoint at `/.well-known/jwks.json` for distributing public keys used to verify JWT signatures
- Feature: **RSA (RS256) JWT Signing** - Migration from HS256 (symmetric) to RS256 (asymmetric) with automatic key generation and rotation support
- Feature: **Key Rotation Support** - Multiple active keys with unique `kid` identifiers for seamless key rotation
```

**Add to Improvements**:
```markdown
- Improvement: **JWT Security** - Migrated from symmetric HS256 to asymmetric RS256, eliminating shared secret risks
- Improvement: **OIDC Compliance** - Now properly implements RS256 as advertised in OpenID Discovery metadata
```

**Acceptance Criteria**:
- [ ] CHANGELOG entries added
- [ ] Entries are clear and concise
- [ ] Placed in correct sections

#### Task 6.2: Create Release Notes

**File**: `Documentation/content/releases/0.10.0.md` (new)

**Content**:
- Breaking changes (if any)
- Migration instructions
- New features summary
- Configuration changes
- Upgrade path

**Acceptance Criteria**:
- [ ] Release notes comprehensive
- [ ] Migration path documented
- [ ] Breaking changes highlighted

## Implementation Checklist

### Phase 1: RSA Key Management â³ PENDING
- [ ] Task 1.1: Create RSA Key Pair Generator
- [ ] Task 1.2: Create JWK Data Models
- [ ] Task 1.3: Implement Key Storage
- [ ] Task 1.4: Update Signer to Support RS256

### Phase 2: JWKS Endpoint Implementation â³ PENDING
- [ ] Task 2.1: Create JWKS Controller
- [ ] Task 2.2: Register JWKS Route
- [ ] Task 2.3: Update JWT Payload to Include "kid"

### Phase 3: Migration Strategy â³ PENDING
- [ ] Task 3.1: Implement Dual-Mode Support
- [ ] Task 3.2: Add Metrics for Key Usage

### Phase 4: Testing â³ PENDING
- [ ] Task 4.1: Unit Tests
- [ ] Task 4.2: Integration Tests
- [ ] Task 4.3: E2E Tests

### Phase 5: Documentation â³ PENDING
- [ ] Task 5.1: Update API Documentation
- [ ] Task 5.2: Update Discovery Documentation
- [ ] Task 5.3: Create Migration Guide
- [ ] Task 5.4: Update Metrics Documentation

### Phase 6: CHANGELOG and Release â³ PENDING
- [ ] Task 6.1: Update CHANGELOG
- [ ] Task 6.2: Create Release Notes

## Estimated Timeline

- **Phase 1**: 6-8 hours (RSA Key Management)
- **Phase 2**: 3-4 hours (JWKS Endpoint)
- **Phase 3**: 4-5 hours (Migration Strategy)
- **Phase 4**: 5-6 hours (Testing)
- **Phase 5**: 3-4 hours (Documentation)
- **Phase 6**: 1 hour (Release Prep)

**Total Estimated Time**: 22-28 hours (~1 week of focused work)

## Risk Assessment

### High Risk
- âš ï¸ **Breaking Change**: Migrating from HS256 to RS256 could break existing integrations
- âš ï¸ **Key Management**: RSA key generation and storage must be secure
- âš ï¸ **Performance**: RSA operations are slower than HMAC

### Medium Risk
- âš ï¸ **Migration Complexity**: Dual-mode support adds code complexity
- âš ï¸ **Key Rotation**: Coordination needed during key rollover
- âš ï¸ **Backward Compatibility**: Must support old HS256 tokens during migration

### Low Risk
- âœ… **JWKS Endpoint**: Straightforward implementation, well-defined spec
- âœ… **JWTKit Support**: Library already supports RS256
- âœ… **Testing**: Can test thoroughly before deployment

### Mitigation Strategies
- Implement dual-mode support for gradual migration
- Use feature flags for RS256 rollout
- Extensive testing with both algorithms
- Clear documentation for operators
- Monitoring and metrics for migration progress
- Rollback plan if issues detected

## Success Criteria

1. âœ… RFC 7517 compliance validated
2. âœ… `/.well-known/jwks.json` endpoint returns valid JWK Set
3. âœ… RS256 signing and verification works correctly
4. âœ… Key rotation supported with multiple active keys
5. âœ… Backward compatibility maintained during migration
6. âœ… All unit tests pass (>90% coverage)
7. âœ… Integration tests pass
8. âœ… E2E tests pass in all browsers
9. âœ… Documentation complete and accurate
10. âœ… No security vulnerabilities introduced
11. âœ… Performance acceptable (token signing/verification < 10ms)
12. âœ… Metrics tracking implemented

## Security Considerations

### Private Key Protection
- **Storage**: Private keys stored with 0600 permissions
- **Encryption**: Consider JWE encryption for key files
- **Access**: Only Uitsmijter process can read private keys
- **Rotation**: Regular key rotation (recommended: every 90 days)

### Algorithm Security
- **RS256 Recommended**: Use 2048-bit or 4096-bit RSA keys
- **No HS256 in Production**: Deprecate symmetric signing
- **Key Strength**: Minimum 2048-bit RSA (4096-bit for high security)

### JWKS Endpoint Security
- **Public Keys Only**: Never expose private key material
- **Rate Limiting**: Prevent abuse of JWKS endpoint
- **CORS**: Enable CORS for legitimate cross-origin requests
- **Caching**: Encourage client-side caching to reduce load

### Token Verification
- **Issuer Validation**: Always validate `iss` claim
- **Audience Validation**: Always validate `aud` claim
- **Expiration**: Always validate `exp` claim
- **Not Before**: Validate `nbf` claim if present

## Future Enhancements (Out of Scope)

- Elliptic Curve keys (ES256, ES384, ES512) - RFC 7518
- Token introspection with key metadata - RFC 7662
- JWT encryption (JWE) support - RFC 7516
- Hardware Security Module (HSM) integration
- Automatic key rotation based on age/usage
- Key revocation and blacklisting
- Certificate-bound tokens - RFC 8705
- Mutual TLS (mTLS) for enhanced security
